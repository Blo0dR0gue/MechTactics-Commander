import { Database } from 'sqlite';
import {
  ForcefullyOmit,
  ObjectWithKeys,
  OnlyFirst
} from '../../types/UtilityTypes';

export type Statement = {
  sql: string;
  params?: unknown[];
};

export type OrderBy<DataObject extends ObjectWithKeys> = {
  [key in keyof DataObject]?: 'ASC' | 'DESC';
};

// TODO: Make updates use partial data (require the keys)
// TODO: Validate input values, iff they are allowed!
export class BaseRepository<
  DataObject extends ObjectWithKeys,
  Key extends { [key in keyof DataObject]?: DataObject[key] },
  AutoGenerated extends { [key in keyof DataObject]?: DataObject[key] }
> {
  protected database: Database;
  protected tableName: string;
  protected booleanColumns: string[] = [];
  protected allowedColumns: string[] = [];

  public constructor(database: Database, tableName: string) {
    this.database = database;
    this.tableName = tableName;
    this.loadTableColumns();
  }

  public async getByKey(
    key: OnlyFirst<Key, DataObject>
  ): Promise<DataObject | null> {
    const { keyWhere, keyValues } = this.getKeyWhere(key);

    const stmt = await this.database.prepare(
      `SELECT * FROM ${this.tableName} WHERE ${keyWhere};`
    );

    const result = await stmt.get<DataObject | undefined>(keyValues);

    if (!result) {
      return null;
    }

    const booleanFields = {};

    Object.keys(result).forEach((keyName) => {
      booleanFields[keyName] = this.databaseValueToJS(keyName, result[keyName]);
    });

    return { ...result, ...booleanFields };
  }

  public async getAll(
    orderBy: OrderBy<DataObject> = {}
  ): Promise<DataObject[]> {
    this.validateColumns(Object.keys(orderBy));

    const orderByCondition = Object.keys(orderBy)
      .map((oderByKeyName) => {
        const value = orderBy[oderByKeyName];
        if (value === 'ASC') {
          return `${oderByKeyName} ASC`;
        } else {
          return `${oderByKeyName} DESC`;
        }
      })
      .join(', ');

    const results = await this.database.all<DataObject[]>(
      `SELECT * FROM ${this.tableName}${
        orderByCondition ? ` ORDER BY ${orderByCondition}` : ''
      };`
    );

    results.forEach((result) => {
      const booleanFields = {};
      Object.keys(result).forEach((key) => {
        booleanFields[key] = this.databaseValueToJS(key, result[key]);
      });
      result = { ...result, ...booleanFields };
    });

    return results;
  }

  public async deleteByKey(key: OnlyFirst<Key, DataObject>): Promise<boolean> {
    const { keyWhere, keyValues } = this.getKeyWhere(key);

    const stmt = await this.database.prepare(
      `DELETE FROM ${this.tableName} WHERE ${keyWhere};`
    );

    const result = await stmt.run(keyValues);

    return result.changes === 1;
  }

  public async create(
    data: ForcefullyOmit<DataObject, keyof AutoGenerated>
  ): Promise<number> {
    this.validateColumns(Object.keys(data));

    const columns = Object.keys(data).join(', ');
    const placeholders = Object.keys(data)
      .map(() => '?')
      .join(', ');

    const createValues = Object.keys(data).map((key) =>
      this.jsToDatabaseValue(data[key])
    );

    const stmt = await this.database.prepare(
      `INSERT INTO ${this.tableName} (${columns}) VALUES (${placeholders})`
    );

    const result = await stmt.run(createValues);

    if (result.lastID === undefined || result.lastID === null) {
      throw new Error(`${this.tableName} could not be created.`);
    }

    return result.lastID;
  }

  public async createOrUpdate(
    key: OnlyFirst<Key, DataObject>,
    data: ForcefullyOmit<DataObject, keyof Key>
  ): Promise<number | null> {
    this.validateColumns(Object.keys(key));
    this.validateColumns(Object.keys(data));

    const keyColumns = Object.keys(key);
    const dataColumns = Object.keys(data);
    const allColumns = [...keyColumns, ...dataColumns];

    const placeholders = allColumns.map(() => '?').join(', ');

    const updateClause = dataColumns
      .map((col) => `${col} = EXCLUDED.${col}`)
      .join(', ');

    const values = allColumns.map((col) =>
      this.jsToDatabaseValue(col in key ? key[col] : data[col])
    );

    const stmt = await this.database.prepare(
      `INSERT INTO ${this.tableName} (${allColumns.join(', ')})
       VALUES (${placeholders})
       ON CONFLICT(${keyColumns.join(', ')}) DO UPDATE SET ${updateClause};`
    );

    const result = await stmt.run(values);

    return result.lastID ?? null;
  }

  public async updateByKey(
    key: OnlyFirst<Key, DataObject>,
    data: ForcefullyOmit<DataObject, keyof Key>
  ): Promise<boolean> {
    const { keyWhere, keyValues } = this.getKeyWhere(key);
    this.validateColumns(Object.keys(data));

    const setClause = Object.keys(data)
      .map((key) => `${key} = ?`)
      .join(', ');

    const setValues = Object.keys(data).map((key) =>
      this.jsToDatabaseValue(data[key])
    );

    const stmt = await this.database.prepare(
      `UPDATE ${this.tableName} SET ${setClause} WHERE ${keyWhere};`
    );

    const updateResult = await stmt.run([...setValues, ...keyValues]);

    return updateResult.changes === 1;
  }

  public async runTransaction<T>(transactionFn: () => Promise<T>): Promise<T> {
    try {
      await this.database.run('BEGIN TRANSACTION;');
      const result = await transactionFn(); // Run the passed function inside the transaction
      await this.database.run('COMMIT;');
      return result;
    } catch (reason: unknown) {
      await this.database.run('ROLLBACK;');
      if (reason instanceof Error) {
        throw new Error(`Operation failed - ${reason.message}`, {
          cause: reason
        });
      }
      throw new Error(`Operation failed - Unknown error: ${String(reason)}`, {
        cause: reason
      });
    }
  }

  private async loadTableColumns() {
    const result = await this.database.all<{ name: string; type: string }[]>(
      `PRAGMA table_info(${this.tableName});`
    );

    this.booleanColumns = result
      .filter((column) => column.type.toUpperCase().includes('BOOLEAN'))
      .map((column) => column.name);

    this.allowedColumns = result.map((column) => column.name);
  }

  private validateColumns(columns: string[]): void | never {
    const columnReg = /^[a-zA-Z]+$/;
    const columnsAllowed = columns.every(
      (column) => this.allowedColumns.includes(column) && columnReg.test(column)
    );
    if (!columnsAllowed) {
      throw new Error(`Not allowed column in list: ${columns.join(', ')}`);
    }
  }

  private jsToDatabaseValue(value: unknown): 0 | 1 | unknown {
    if (typeof value === 'boolean') {
      return value ? 1 : 0;
    }
    return value;
  }

  private databaseValueToJS(key: string, value: unknown): boolean | unknown {
    if (
      this.booleanColumns.includes(key) &&
      typeof value === 'number' &&
      (value === 0 || value === 1)
    ) {
      return value === 1;
    }
    return value;
  }

  private getKeyWhere(
    key: Key
  ): { keyWhere: string; keyValues: unknown[] } | never {
    this.validateColumns(Object.keys(key));

    const whereCondition = Object.keys(key)
      .map((keyName) => `${keyName} = ?`)
      .join(' AND ');

    const keyValues = Object.keys(key).map((keyName) =>
      this.jsToDatabaseValue(key[keyName])
    );

    return { keyWhere: whereCondition, keyValues: keyValues };
  }
}
